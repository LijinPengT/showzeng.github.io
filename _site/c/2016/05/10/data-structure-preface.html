<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
    <title>数据结构之前言</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="description" content="showzeng's blog" />
    <meta name="keywords" content="" />
    <meta name="author" content="showzeng" />
    <meta name="copyright" content="showzeng" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style type="text/css">

    </style>
    <link rel="stylesheet" href="/assets/css/footer.css" type="text/css" />
    <link rel="stylesheet" href="/assets/css/post.css" type="text/css" />
    <link rel="stylesheet" href="/assets/css/syntax.css" type="text/css" />
    <link rel="shortcut icon" href="http://7xtt0k.com1.z0.glb.clouddn.com/image/myblog/head-brains.png" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Atom" href="" />

</head>

<body>
    <div id="post-container">
        <div class="post-title">
            <div class="inner-title">
                <div class="post-title-back">
                    <a href="/" class="home-link"><img src="http://7xtt0k.com1.z0.glb.clouddn.com/image/myblog/home2.png" class="home" /></a>
                </div>
                <div class="post-article-title">
                    <p>数据结构之前言</p>
                </div>
            </div>
        </div>
        <div class="post-content">

            <blockquote>
  <p>计算机内存分配</p>
</blockquote>

<p>首先要清楚的是，在计算机中，并不存在内容的删除，只有内容的覆盖，这也是为什么会有数据恢复这种技术了！</p>

<p><img src="http://7xtt0k.com1.z0.glb.clouddn.com/data.png" alt="空闲区与占用区" /></p>

<p>比如说你在word里编辑你的文件，假如你输入了三个字符，你删除之后，你认为就安全了吗？别人不可能恢复了吗？这样做还是不能销毁你的记录，只有通过更大的内容去覆盖你之前的内容，这样，之前的内容才会被“销毁”。尼玛，真有趣！</p>

<p>值得注意的是，在空闲区也是可能有原始数据的。</p>

<p>在c里 , &amp;表示取地址 , *表示取内容</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">//这里的*与取内容区分一下，这里是申明p为地址变量，用来存放地址
</span><span class="kt">int</span> <span class="o">**</span><span class="n">q</span><span class="p">;</span> <span class="c1">//那么这里的q就是存放地址变量的地址
</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">//这里将x的地址传给了p这个地址变量，如果此时输出p，将是一个x的地址
</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span> <span class="c1">//这里将p这个地址变量的地址传给了q这个地址变量，如果此时输出q，将是一个p的地址
</span></code></pre>
</div>

<p>那么<em>p = x   ，   *q = p  ，    *(</em>q) = x = 2</p>

<blockquote>
  <p>指针的风险——悬挂式指针</p>
</blockquote>

<p>为什么说使用指针是要谨慎，因为一不小心就可能造成系统的崩溃，让我们来看看是怎么回事。</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
</code></pre>
</div>

<p>上面这个程序，利用了一个中间变量实现了a,b的数据交换，看似是没有问题的，好像我也是经常这样干！
但是，在内存的分配里我们讲到了空闲区也有可能是有它原本的数据存在的。这里我们假设一下，如果申请的指针变量t原本就是有数据假设为1000，那么我们将a=1暂存到t指针所指向的地址空间，即地址为1000的这个空间，如果说恰好地址为1000的空间又是存放系统文件的，那么不可避免的造成bug、死机甚至是系统的崩溃。</p>

<blockquote>
  <p>数组存取</p>
</blockquote>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
</code></pre>
</div>
<p>一个整型占两个字节，这里系统会为这个数组申请18个字节的空间：</p>

<p><img src="http://7xtt0k.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.png" alt="数组存储" /></p>

<p>而a就是首地址，即：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">//这里隐含的地址+4
</span></code></pre>
</div>

<p>而：</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">];</span>
</code></pre>
</div>

<p><img src="http://7xtt0k.com1.z0.glb.clouddn.com/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.png" alt="二维数组存储" /></p>

<p>除b[?][?]表示是具体的数值外，其它表示全为地址</p>

<p>eg：  b+1为b[1]的地址————行地址
b[0]+1为b[0][1]的地址————列地址</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">//列地址
</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">//行地址，这里q+1将会跳5个数据，q相当于b
</span><span class="kt">int</span> <span class="o">*</span><span class="n">t</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">//数组指针
</span></code></pre>
</div>

            <!-- 多说评论框 start -->
            <div class="ds-thread" data-thread-key="/c/2016/05/10/data-structure-preface" data-title="数据结构之前言" data-url="showzeng.github.io{page.url}"></div>
            <!-- 多说评论框 end -->
            <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
            <script type="text/javascript">
                var duoshuoQuery = {
                    short_name: "showzeng"
                };
                (function() {
                    var ds = document.createElement('script');
                    ds.type = 'text/javascript';
                    ds.async = true;
                    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                    ds.charset = 'UTF-8';
                    (document.getElementsByTagName('head')[0] ||
                        document.getElementsByTagName('body')[0]).appendChild(ds);
                })();
            </script>
            <!-- 多说公共JS代码 end -->
        </div>
        <a href="" class="up-to-top" id="up-to-top" title="up to the top">
            <img src="http://7xtt0k.com1.z0.glb.clouddn.com/image/myblog/fangxiang3.png" class="up-to-top-img" />
        </a>
    </div>

    <div id="footer">
    <p>&copy; 2016 showzeng</p>
</div>

</body>

<script type="text/javascript">
    window.onscroll = function() {
        console.log(document.body.scrollTop)
        if (document.body.scrollTop >= window.innerHeight) {
          // alert("You should show up");
            document.getElementById('up-to-top').className = 'up-to-top fixed'
        } else {
            document.getElementById('up-to-top').className = 'up-to-top'
        }
    }

    var hiddenProperty = 'hidden' in document ? 'hidden' :
        'webkitHidden' in document ? 'webkitHidden' :
        'mozHidden' in document ? 'mozHidden' :
        null;
    var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, 'visibilitychange');
    var onVisibilityChange = function() {
        if (!document[hiddenProperty]) {
            document.title = "ˇε ˇ 数据结构之前言"
        } else {
            document.title = ":-( 不要离开我"
        }
    }
    document.addEventListener(visibilityChangeEvent, onVisibilityChange);
</script>

</html>
